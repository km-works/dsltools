/*
 *   Copyright (C) 2012-2017 Christian P. Lerch, Vienna, Austria.
 *
 *   This file is part of DSLtools - a suite of software tools for effective
 *   DSL implementations.
 *
 *   DSLtools is free software: you can use, modify and redistribute it under
 *   the terms of the GNU General Public License version 3 as published by
 *   the Free Software Foundation, Inc. <http://fsf.org/>
 *
 *   DSLtools is distributed in the hope that it will be useful, but WITHOUT
 *   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *   version 3 for details.
 *
 *   You should have received a copy of the GNU General Public License along
 *   with this distribution. If not, see <http://www.gnu.org/licenses/gpl-3.0.html>.
 */
package kmworks.dsltools.rrd;

import static com.google.common.base.Preconditions.*;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.font.FontRenderContext;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import kmworks.util.config.PropertyMap;
import nu.xom.Attribute;
import nu.xom.Comment;
import nu.xom.Element;

/**
 *
 * @author Christian P. Lerch
 * @version 1.0.0
 * @since 1.0
 */
public final class SVGRenderer {

    public static final String XHTML_NS = "http://www.w3.org/1999/xhtml";
    public static final String SVG_NS   = "http://www.w3.org/2000/svg";
    public static final String XLINK_NS = "http://www.w3.org/1999/xlink";
    public static final String XMLEV_NS = "http://www.w3.org/2001/xml-events";
    public static final Font DEF_FONT = new Font(Font.SANS_SERIF, Font.PLAIN, 12);

    private final List<Element> parts = new ArrayList<>();
    private final List<String> names = new ArrayList<>();
    private final Element root;
    private final PropertyMap opts;
    
    private Element curr;

    public SVGRenderer(PropertyMap options) {
        checkNotNull(options);
        opts = options;
        root = new Element(getOption("root.elem", "div"));
        root.appendChild(new Comment(" Generated by km-works.eu DSLtools \u2012 SVG Syntax Diagram Generator "));
        curr = root;
    }

    public List<Element> getParts() {
        return parts;
    }
    
    public List<String> getNames() {
        return names;
    }
    
    public void beginSVGElement(int width, int height) {
        beginSVGElement(width, height, null);
    }

    public void beginSVGElement(int width, int height, String id) {
        Element svg = svgElem("svg");
        svg.addNamespaceDeclaration("xlink", XLINK_NS);     //TODO: make xlinks work again
        svg.addAttribute(mkAttr("version", "1.1"));
        svg.addAttribute(mkAttr("style", defaultStyles()));
        svg.addAttribute(mkAttr("baseProfile", "full"));
        svg.addAttribute(mkAttr("width", String.valueOf(width) + "px"));
        svg.addAttribute(mkAttr("height", String.valueOf(height) + "px"));
        
        Element group = svgElem("g");
        group.addAttribute(mkAttr("display", "block"));
        
        svg.appendChild(group);
        parts.add(svg);
        names.add(id);
        curr = group;
    }

    /*
     * Drawing primitives
     */
    public void drawLine(int x0, int y0, int x1, int y1) {
        // <line fill="none" x1="`x0`" y1="`y0`" x2="`x1`" y2="`y1`" />
        Element res = svgElem("line");
        res.addAttribute(mkAttr("fill", "none"));
        res.addAttribute(mkAttr("x1", x0));
        res.addAttribute(mkAttr("y1", y0));
        res.addAttribute(mkAttr("x2", x1));
        res.addAttribute(mkAttr("y2", y1));
        curr.appendChild(res);
    }
    
    public void drawRect(Point upperLeft, Point lowerRight) {
        drawRect(upperLeft.x, upperLeft.y, lowerRight.x - upperLeft.x, lowerRight.y - upperLeft.y);
    }

    public void drawRect(int x0, int y0, int width, int height) {
        // <rect fill="none" x="`x0`" y="`y0`" width="`width`" height="`height`" />
        Element res = svgElem("rect");
        res.addAttribute(mkAttr("fill", "none"));
        res.addAttribute(mkAttr("x", x0));
        res.addAttribute(mkAttr("y", y0));
        res.addAttribute(mkAttr("width", width));
        res.addAttribute(mkAttr("height", height));
        curr.appendChild(res);
    }

    public void drawRoundRect(int x0, int y0, int width, int height, int radius) {
        // <rect fill="none" x="`x0`" y="`y0`" width="`width`" height="`height`"
        //      rx="`radius`" ry="`radius`" />
        Element res = svgElem("rect");
        res.addAttribute(mkAttr("fill", "none"));
        res.addAttribute(mkAttr("x", x0));
        res.addAttribute(mkAttr("y", y0));
        res.addAttribute(mkAttr("width", width));
        res.addAttribute(mkAttr("height", height));
        res.addAttribute(mkAttr("rx", radius));
        res.addAttribute(mkAttr("ry", radius));
        curr.appendChild(res);
    }

    public void drawText(int x0, int y0, String text) {
        drawText(x0, y0, text, null);
    }
    public void drawText(int x0, int y0, String text, String fill) {
        // <text stroke="none" x="`x0`" y="`y0`">`text`</text>
        Element res = svgElem("text");
        res.addAttribute(mkAttr("stroke", "none"));
        res.addAttribute(mkAttr("x", x0));
        res.addAttribute(mkAttr("y", y0));
        if (fill != null) {
            res.addAttribute(mkAttr("fill", fill));
        }
        res.appendChild(text);
        curr.appendChild(res);
    }

    public void drawAnchoredText(int x0, int y0, String text) {
        // <text id="`text`" stroke="none" x="`x0`" y="`y0`">`text`</text>
        Element res = svgElem("text");
        res.addAttribute(new Attribute("id", text));
        res.addAttribute(mkAttr("stroke", "none"));
        res.addAttribute(mkAttr("style", "font-size:larger"));
        res.addAttribute(mkAttr("x", x0));
        res.addAttribute(mkAttr("y", y0));
        res.appendChild(text);
        curr.appendChild(res);
    }

    public void drawHyperlink(int x0, int y0, String text, URI uri) {
        // <a xlink:href="`uri`">`drawText(x0, y0, text)`</a>
        Element res = svgElem("a");
        res.addAttribute(new Attribute("xlink:href", XLINK_NS, uri.toASCIIString()));
        curr.appendChild(res);
        curr = res;
        drawText(x0, y0, text);
        curr = (Element) curr.getParent();
    }

    // Draw quarter circular arc around center (x0,y0) in given quadrant
    // Quadrants are numbered anti-clockwise 1-2-3-4 with 1st quadrant between
    // positive x,y-axes
    public void quaterArc(int x0, int y0, int radius, int quadrant) {
        // <path fill="none" d="M`start.x` `start.y` A`radius` `radius`
        //                      0 0 0 `end.x` `end.y`"/>
        Element res = svgElem("path");
        res.addAttribute(mkAttr("fill", "none"));
        res.addAttribute(mkAttr("d", pathValue(new Point(x0, y0), radius, quadrant)));
        curr.appendChild(res);
    }

    public void drawArrowRight(int x0, int y0) {
        drawArrowRight(x0, y0, 5);
    }
    
    public void drawArrowRight(int x0, int y0, int size) {    
        drawLine(x0, y0, x0 - size, y0 - size);
        drawLine(x0, y0, x0 - size, y0 + size);
    }
    
    public void drawArrowLeft(int x0, int y0, int size) {    
        drawLine(x0, y0, x0 + size, y0 - size);
        drawLine(x0, y0, x0 + size, y0 + size);
    }
    
    public void drawArrowDown(int x0, int y0, int size) {    
        drawLine(x0, y0, x0 + size, y0 - size);
        drawLine(x0, y0, x0 - size, y0 - size);
    }
    
    /** Draw symmetric, rectangular triangle with origin on to x-axis.
     *                        
     * @param x0    x-origin 
     * @param y0    y-origin  
     * @param size            
     *                        
     */
    public void drawTriangleRight(int x0, int y0, int size) {
        drawArrowRight(x0, y0, size);
        drawLine(x0 - size, y0 - size, x0 - size, y0 + size);
    }

    public void drawTriangleLeft(int x0, int y0, int size) {
        drawArrowLeft(x0, y0, size);
        drawLine(x0 + size, y0 - size, x0 + size, y0 + size);
    }

    // debugging aids
    public void horRuler(Point o, int len, int scale) {
        drawLine(o.x, o.y, o.x + len, o.y);
        for (int i = 0; i < len / scale; i++) {
            int size = (i % 10 == 0 ? 6 : 3);
            drawLine(o.x + i * scale, o.y, o.x + i * scale, o.y + size);
        }
    }

    public void verRuler(Point o, int len, int scale) {
        drawLine(o.x, o.y, o.x, o.y + len);
        for (int i = 0; i < len / scale; i++) {
            int size = (i % 10 == 0 ? 6 : 3);
            drawLine(o.x, o.y + i * scale, o.x + size, o.y + i * scale);
        }
    }

    private Element svgElem(String name) {
        return new Element(name, SVG_NS);    // no prefix needed: SVG_NS is the default ns
    }

    private Attribute mkAttr(String name, String value) {
        return new Attribute(name, value);
    }

    private Attribute mkAttr(String name, int value) {
        return new Attribute(name, String.valueOf(value));
    }

    private String defaultStyles() {
        StringBuilder sb = new StringBuilder();
//    sb.append("fill-opacity:1; ");
//    sb.append("color-rendering:auto; ");
//    sb.append("color-interpolation:auto; ");
//    sb.append("fill:black; ");
        sb.append("stroke:black; ");
//    sb.append("stroke-dasharray:none; ");
//    sb.append("stroke-width:1; ");
//    sb.append("stroke-dashoffset:0; ");
//    sb.append("stroke-linejoin:miter; ");
//    sb.append("stroke-linecap:square; ");
//    sb.append("stroke-miterlimit:10; ");
//    sb.append("stroke-opacity:1; ");
//    sb.append("shape-rendering:auto; ");
//    sb.append("image-rendering:auto; ");
        sb.append("font-family:")
                .append(getOption("font.family", DEF_FONT.getFamily()))
                .append("; ");
        sb.append("font-size:")
                .append(getOption("font.size", String.valueOf(DEF_FONT.getSize())))
                .append("px; ");
        String fontStyle = getOption("font.style");
        String fontWeight = getOption("font.weight");
        if (fontStyle == null || fontWeight == null) {
            sb.append(decodeFontStyle(DEF_FONT.getStyle()));
        } else {
            if (!fontStyle.equals("normal")) {
                sb.append("font-style:").append(fontStyle).append("; ");
            }
            if (!fontWeight.equals("normal")) {
                sb.append("font-weight:").append(fontWeight).append("; ");
            }
        }
//    sb.append("text-rendering:auto");
        return sb.toString();
    }

    private String decodeFontStyle(int fontStyle) {
        switch (fontStyle) {
            case Font.BOLD:
                return "font-style:normal; font-weight:bold; ";
            case Font.ITALIC:
                return "font-style:italic; font-weight:normal; ";
            case Font.BOLD + Font.ITALIC:
                return "font-style:italic; font-weight:bold; ";
            case Font.PLAIN:
            default:
                return "";  // no need to post default "font-style:normal; font-weight:normal;"
        }
    }

    private String pathValue(Point center, int radius, int quadrant) {
        Point start = arcStart(center, radius, quadrant);
        Point end = arcStart(center, radius, quadrant + 1);
        StringBuilder sb = new StringBuilder();
        sb.append('M').append(String.valueOf(start.x));
        sb.append(' ').append(String.valueOf(start.y)).append(' ');
        sb.append('A').append(String.valueOf(radius));
        sb.append(' ').append(String.valueOf(radius)).append(" 0 0 0");
        sb.append(' ').append(String.valueOf(end.x));
        sb.append(' ').append(String.valueOf(end.y));
        return sb.toString();
    }

    private Point arcStart(Point o, int r, int q) {
        switch ((q - 1) % 4 + 1) {
            case 1:
                return new Point(o.x + r, o.y);
            case 2:
                return new Point(o.x, o.y - r);
            case 3:
                return new Point(o.x - r, o.y);
            case 4:
                return new Point(o.x, o.y + r);
            default:
                throw new IllegalArgumentException("Illegal quadrant: " + String.valueOf(q));
        }
    }

    private String getOption(String key) {
        return getOption(key, null);
    }

    private String getOption(String key, String def) {
        String res = opts.get(key);
        return res != null ? res : def;
    }

    // Measure a text against the current font
    public static TextMetric measureText(String text) {
        return measureText(text, null);
    }
    // Measure a text against a given font

    public static TextMetric measureText(String text, Font font) {
        BufferedImage img = new BufferedImage(200, 100, BufferedImage.TYPE_BYTE_GRAY);
        Graphics2D g = img.createGraphics();
        Font f = (font == null) ? g.getFont() : font;
        g.setFont(f);
        FontRenderContext frc = g.getFontRenderContext();
        Rectangle2D bounds = f.getStringBounds(text, frc);
        float width = (float) bounds.getWidth();    // The width of text
        float height = (float) bounds.getHeight();  // Total line height
        return new TextMetric(width, height);
    }

    public static void markPoint(Graphics2D g, Point p) {
        int OFFS = 5;
        int R = 1;
        Font currFont = g.getFont();
        Color currColor = g.getColor();
        Font f = new Font(Font.SERIF, Font.ITALIC, 8);
        g.setFont(f);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        StringBuilder lbl = new StringBuilder();
        lbl.append('(').append(p.x).append(',').append(p.y).append(')');
        g.setColor(Color.red);
        g.drawString(lbl.toString(), p.x + OFFS, p.y + OFFS);
        g.drawOval(p.x - R, p.y - R, 2 * R, 2 * R);
        g.setFont(currFont);
        g.setColor(currColor);
    }

}
