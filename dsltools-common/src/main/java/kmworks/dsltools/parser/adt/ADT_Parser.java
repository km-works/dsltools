// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// Do NOT manually edit!
// ===========================================================================

package kmworks.dsltools.parser.adt;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.*;
import kmworks.dsltools.parser.base.*;
import kmworks.dsltools.ast.base.*;
import kmworks.dsltools.ast.adt.*;
import static kmworks.dsltools.parser.base.CodepointUtils.*;

/**
 * Packrat parser for grammar <code>ADT</code>.
 *
 * <p>This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class ADT_Parser extends AbstractParser {

  /** The JAVA_RESERVED_WORDS set. */
  public static final Set<String> JAVA_RESERVED_WORDS = new HashSet<String>();

  /** The JAVA_RESERVED_TYPES set. */
  public static final Set<String> JAVA_RESERVED_TYPES = new HashSet<String>();

  // =========================================================================

  /** Memoization table column. */
  static final class ADT_ParserColumn extends Column {
    Result fTypeDef;
    Result fTypeDef$$Plus1;
    Result fParameter;
    Result fNBlockComment;
    Result fJIdentifier;
    Result fJPkgNamePart;
    Result fIdentifier;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public ADT_Parser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public ADT_Parser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new ADT_ParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.Start.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public final Result pStart(final int yyStart) throws IOException {
    Result     yyResult;
    Grammar    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPackage(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> p = yyResult.semanticValue();

        yyResult = pADT(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ADT a = yyResult.semanticValue();

          yyResult = pEOI(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = NodeFactory.mkGrammar(p, a);

            setLocation(yyValue, yyStart);
            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.ADT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pADT(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    boolean       yyRepeated1;
    Pair<TypeDef> yyRepValue1;
    int           yyOption1;
    Pair<TypeDef> yyOpValue1;
    ADT           yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLADT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String n = yyResult.semanticValue();

        yyResult = pwr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pTypeDef(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              TypeDef v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<TypeDef>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }

          if (yyRepeated1) {
            Pair<TypeDef> main = yyRepValue1.reverse();

            yyOption1  = yyRepetition1;
            yyOpValue1 = null;

            yyResult = pLAUX(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepeated1   = false;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pTypeDef(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  TypeDef v$el$3 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  yyRepValue1   = new Pair<TypeDef>(v$el$3, yyRepValue1);
                  continue;
                }
                break;
              }

              if (yyRepeated1) {
                Pair<TypeDef> v$el$2 = yyRepValue1.reverse();

                yyResult = pRAUX(yyRepetition1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
            { // Start scope for aux.
              Pair<TypeDef> aux = yyOpValue1;

              yyResult = pRADT(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = NodeFactory.mkADT(n, main, aux);

                setLocation(yyValue, yyStart);
                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for aux.
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.TypeDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDef(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fTypeDef) yyColumn.fTypeDef = pTypeDef$1(yyStart);
    return yyColumn.fTypeDef;
  }

  /** Actually parse ADT.TypeDef. */
  private Result pTypeDef$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    TypeDef    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJKind(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for k.
      String k = cast(yyOpValue1);

      yyResult = pJIdentifier(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String n = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            Pair<Parameter> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for p.
            Pair<Parameter> p = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pLCURLY(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {

              yyResult = pTypeDef$$Plus1(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                Pair<TypeDef> v$el$3 = yyResult.semanticValue();

                yyResult = pRCURLY(yyResult.index);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
            { // Start scope for d.
              Pair<TypeDef> d = cast(yyOpValue1);

              yyValue = NodeFactory.mkTypeDef(n, k, p, d);

              setLocation(yyValue, yyStart);
              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for d.
          } // End scope for p.
        }
      }
    } // End scope for k.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal ADT.TypeDef$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDef$$Plus1(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fTypeDef$$Plus1) 
      yyColumn.fTypeDef$$Plus1 = pTypeDef$$Plus1$1(yyStart);
    return yyColumn.fTypeDef$$Plus1;
  }

  /** Actually parse ADT.TypeDef$$Plus1. */
  private Result pTypeDef$$Plus1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<TypeDef> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeDef v$el$4 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pTypeDef$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<TypeDef> v$5 = yyResult.semanticValue();

        yyValue = new Pair<TypeDef>(v$el$4, v$5);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<TypeDef>(v$el$4);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.Parameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameters(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<Parameter> yyRepValue1;
    Pair<Parameter> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pParameter(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Parameter v$l$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCOMMA(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pParameter(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              Parameter v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Parameter>(v$el$1, yyRepValue1);
              continue;
            }
          }
          break;
        }
        { // Start scope for v$l$2.
          Pair<Parameter> v$l$2 = yyRepValue1.reverse();

          yyResult = pRPAREN(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Pair<Parameter>(v$l$1, v$l$2);

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$l$2.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.Parameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fParameter) 
      yyColumn.fParameter = pParameter$1(yyStart);
    return yyColumn.fParameter;
  }

  /** Actually parse ADT.Parameter. */
  private Result pParameter$1(final int yyStart) throws IOException {
    Result     yyResult;
    Parameter  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String n = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pCOLON(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTypeRef(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            TypeRef r = yyResult.semanticValue();

            yyValue = NodeFactory.mkParameter(n, r);

            setLocation(yyValue, yyStart);
            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.TypeRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeRef(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Character  yyOpValue1;
    TypeRef    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String n = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;
        char v$el$1 = (char)yyC;

        if ((('*' <= v$el$1) && (v$el$1 <= '+')) ||
            ('?' == v$el$1)) {

          yyOption1  = yyIndex;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for m.
        Character m = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = NodeFactory.mkTypeRef(n, m);

          setLocation(yyValue, yyStart);
          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for m.
    }

    // Done.
    yyError = yyError.select("type ref expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.JKind.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJKind(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "enum";

            yyResult = pwr(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("j kind expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.Package.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPackage(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPKG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJPkgNamePart(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String f = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pDOT(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyResult = pJPkgNamePart(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              String v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
              continue;
            }
          }
          break;
        }
        { // Start scope for r.
          Pair<String> r = yyRepValue1.reverse();

          yyResult = pwr(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Pair<String>(f, r);

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for r.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.PKG.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPKG(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('k' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pwr(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = null;

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("PKG expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.LADT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLADT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('D' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('T' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('>' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("LADT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.RADT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRADT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('A' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('D' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('T' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('>' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pw(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("RADT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.LAUX.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLAUX(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('U' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('X' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('>' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pw(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("LAUX expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.RAUX.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRAUX(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('A' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('U' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('X' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('>' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pw(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("RAUX expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.LCURLY.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLCURLY(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LCURLY expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.RCURLY.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRCURLY(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RCURLY expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.LPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLPAREN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.RPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRPAREN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.COMMA.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOMMA(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COMMA expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.COLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ADT.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpacing(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.wr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpacing(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.EOI.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOI(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOI expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (contains(c, WHITESPACE$SYNTAX_MODULE, WHITESPACE_CHARS)) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (contains(c, WHITESPACE$SYNTAX_MODULE, OTHER_NEWLINE_CHARS)) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pTBCommentContents(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'*/' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pNBlockComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pNewline(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("spacing expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if ('\r' == yyC) {
          yyIndex = yyChoice1 + 1;

          yyC = character(yyIndex);
          if ('\n' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'\\r\\n' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'\\r\\n' expected", yyBase);
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if ('\n' == yyC) {
          yyIndex = yyChoice1 + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

        // Nested alternative 3.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;
          char c = (char)yyC;

          if (contains(c, WHITESPACE$SYNTAX_MODULE, OTHER_NEWLINE_CHARS)) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }

        // Nested alternative 4.

        yyPredResult = pEOI(yyChoice1);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("spacing expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewline(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (contains(c, WHITESPACE$SYNTAX_MODULE, OTHER_NEWLINE_CHARS)) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.TBCommentContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTBCommentContents(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pTBCommentContent(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.TBCommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTBCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyPredMatched = false;

          yyC = character(yyIndex);
          if ('/' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("t b comment content expected", yyStart);
          }
        }
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("t b comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.NBlockComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNBlockComment(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fNBlockComment) 
      yyColumn.fNBlockComment = pNBlockComment$1(yyStart);
    return yyColumn.fNBlockComment;
  }

  /** Actually parse base.GenericSpacing.NBlockComment. */
  private Result pNBlockComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pNBCommentContents(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if (')' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("'*)' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'*)' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("n block comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.NBCommentContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNBCommentContents(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pNBCommentContent(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericSpacing.NBCommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNBCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if (')' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNBlockComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyPredMatched = false;

          yyC = character(yyIndex);
          if (')' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("n b comment content expected", yyStart);
          }
        }
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("n b comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.JavaIdentifier.JIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJIdentifier(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fJIdentifier) 
      yyColumn.fJIdentifier = pJIdentifier$1(yyStart);
    return yyColumn.fJIdentifier;
  }

  /** Actually parse base.JavaIdentifier.JIdentifier. */
  private Result pJIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!contains(JAVA_RESERVED_WORDS, yyValue) && !contains(JAVA_RESERVED_TYPES, yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("j identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.JavaIdentifier.JTypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJTypeName(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!contains(JAVA_RESERVED_TYPES, yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("j type name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.JavaIdentifier.JPkgNamePart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJPkgNamePart(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fJPkgNamePart) 
      yyColumn.fJPkgNamePart = pJPkgNamePart$1(yyStart);
    return yyColumn.fJPkgNamePart;
  }

  /** Actually parse base.JavaIdentifier.JPkgNamePart. */
  private Result pJPkgNamePart$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJPkgNameHead(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String h = yyResult.semanticValue();

      yyResult = pJPkgNameTail(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String t = yyResult.semanticValue();

        yyValue = h + t;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.JavaIdentifier.JPkgNameHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJPkgNameHead(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("j pkg name head expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.JavaIdentifier.JPkgNameTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJPkgNameTail(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        if (('a' <= yyC) && (yyC <= 'z')) {

          yyRepetition1 = yyIndex;
          continue;
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '_':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericIdentifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    ADT_ParserColumn yyColumn = (ADT_ParserColumn)column(yyStart);
    if (null == yyColumn.fIdentifier) 
      yyColumn.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.fIdentifier;
  }

  /** Actually parse base.GenericIdentifier.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifierHead(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String h = yyResult.semanticValue();

      yyResult = pIdentifierTail(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String t = yyResult.semanticValue();

        yyValue = h + t;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericIdentifier.IdentifierHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierHead(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (isIdentifierHeadChar(c)) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier head expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal base.GenericIdentifier.IdentifierTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierTail(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        char c = (char)yyC;

        if (isIdentifierTailChar(c)) {

          yyRepetition1 = yyIndex;
          continue;
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  protected void initParser() {
    setSyntaxType(AbstractParser.IDENTIFIER$SYNTAX_MODULE, Predefined.SyntaxType.JAVA);
  }
  static {
    add(JAVA_RESERVED_WORDS, new String[] {
      "abstract",     "assert",       "break",        "case",         "catch",
      "class",        "const",        "continue",     "default",      "do",
      "else",         "enum",         "extends",      "final",        "finally",
      "for",          "goto",         "if",           "implements",   "import",
      "instanceof",   "interface",    "native",       "new",          "package",
      "private",      "protected",    "public",       "return",       "static",
      "strictfp",     "super",        "switch",       "synchronized", "this",
      "throw",        "throws",       "transient",    "try",          "volatile",
      "while",        "void",         "null",         "true",         "false"
    });
    add(JAVA_RESERVED_TYPES, new String[] {
      "boolean",      "byte",         "char",         "double",       "float",
      "int",          "long",         "short"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
